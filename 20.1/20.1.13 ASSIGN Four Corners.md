# 20.1.13 Assign Four Corners
```
20.1.13 Assign Four Corners
```
**Outcomes:**

* **2.1 Decompose a problem using top-down design.**
* **2.3 Represent relationships among modules.**
* **3.1 Implement a main module coordinating subprograms.**
* **3.4 Maintain balance between coupling and cohesion:** MVC (Model-View-Controller) style structure minimizes dependencies between components.
  ---

> [!TIP]
>
>
>* Use `keyIsDown()` for smooth movement.
> * Remember **logical operators**:
>    * `&&` (AND)
>     * `||` (OR)
>     * `!` (NOT)
>* Track collision status using flags like `isHit`.


---
## TODO:
### **1. Sprite Movement**
Draw your sprite using the `sprite` object.
* Make a function called `movement` that uses the **WASD** keys.
   * We don't want to use `keyPressed` because that only gets called once every time you hold your key down.


   * Call this `momvement` `draw()` so it updates automatically.
* The sprite should **wrap around** the edges of the canvas (disappear off one side, reappear on the opposite side).


> [!NOTE]
> ## INFODUMP:
> * **Detect continuous input:** `keyIsDown()` lets you check if a key is being held
>* **Use numeric keycodes:** Use [keycode chart](https://www.toptal.com/developers/keycode) to find any keyâ€™s number.
> * **MEGA HINT**  look a the p5 refference for [keyIsDown()](https://p5js.org/reference/p5/keyIsDown/)


### **2. Draw Four Shapes**


* Create **four different shapes**, one in each quadrant of the canvas.
   * helper functions for star and poly are below
* Make sure you use objects in the starter code to store each shapes attributes, such as position, colour, and a flag to track collisions


---


### **4. Shape Collision**


* Complete the `distance()` function to detect overlaps using the `dist()` function.
* Inside `draw()`, check each shape for collisions.
* If a collision occurs:


 * Change the **colour of that shape only**.
 * Update its `isHit` flag so it only counts once.
* starter with 1 shape collision, only if that works add on the others.


---


### **5. Counter Implementation**


* Add a counter at the top of the screen showing how many shapes have been hit.
* The counter should **only increase once per shape**.
* Use `isHit` to prevent double-counting.


---


### **6. Add Comments**


* Write meaningful comments throughout your code explaining what each section does.


---


## **Part 2 to get 80% and above**


### **1. Add a Second Player**


* Add a second sprite controlled with the **Arrow Keys**.


### **2. Drag-and-Drop Shapes**


* Allow the user to click and drag shapes to reposition them.


---


## **Starter Code**


### **Model (Data Storage)**


```js
// Model
let sprite = {
   cx: 200,
   cy: 200,
   colour: "white"
  }//end sprite object


let star = {};
let poly = {};
let sqr = {};
let hitCount = 0;
```


### **View (Display Elements)**


```js
// View
function setup() {
   createCanvas(600, 400);
   textSize(24);
   angleMode(DEGREES);
}//end set up


function draw() {
   background(220);


   // Draw counter
   fill(0);
   text("Shapes hit: " + hitCount, 10, 30);


   // Draw player sprite
   fill(sprite.colour);
   ellipse(sprite.cx, sprite.cy, 30, 30);


   // TODO: draw shapes here


   // Call movement
   movement();
}// end draw
```


### **Controller (Logic and Interaction)**


```js
// Controller
function movement() {
   // TODO: add WASD movement
   // Remember to wrap around edges
}// end movement


function distance(x1, y1, x2, y2, r) {
  // return true if colliding,
 // return false if  not
}// end of distance
```






## **Helper Functions**


```js
// Draw polygon
function polygon(x, y, radius, npoints) {
   const angle = 360 / npoints; 
   beginShape();
   for (let i = 0; i < npoints; i++) {
       const currentAngle = angle * i - 90;
       const sx = x + cos(currentAngle) * radius;
       const sy = y + sin(currentAngle) * radius;
       vertex(sx, sy);
   }
   endShape(CLOSE);
}


// Draw star
function drawStar(startX, startY, sides, radius1, radius2) {
   beginShape();
   for (let i = 0; i < sides * 2; i++) {
       let angle = map(i, 0, sides * 2, 0, 360) + 15;
       let r = (i % 2 === 0) ? radius1 : radius2;
       let x = cos(angle) * r + startX;
       let y = sin(angle) * r + startY;
       vertex(x, y);
   }
   endShape(CLOSE);
}
```



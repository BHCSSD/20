# 20.1.13 ASSIGN Four Corners
```
20.1.13 ASSIGN Four Corners
```
> **Outcomes:**
> 
> * **2.1 Decompose a problem using top-down design.**
> * **2.3 Represent relationships among modules.**
> * **3.1 Implement a main module coordinating subprograms.**
> * **3.4 Maintain balance between coupling and cohesion:** MVC (Model-View-Controller) style structure minimizes dependencies between components.
  ---

> [!TIP]
>
> * Use `keyIsDown()` for smooth movement.
> * Remember **logical operators**:
>    * `&&` (AND)
>     * `||` (OR)
>     * `!` (NOT)
> * Track collision status using flags like `isHit`.


---
## TODO:
### **1. Sprite Movement**
Draw your sprite using the `sprite` object.
* Make a function called `movement` that uses the **WASD** keys.
   * * We don't want to use `keyPressed` because that only gets called once every time you hold your key down.
  *   A/D should change the sprite.angle. (see next part for a hint)
  *   W/S should move the sprite forward or backward based on that angle
       
   * Call this `momvement` `draw()` so it updates automatically
* The sprite should **wrap around** the edges of the canvas (disappear off one side, reappear on the opposite side).


> [!NOTE]
> ## INFODUMP:
> * **Detect continuous input:** `keyIsDown()` lets you check if a key is being held
>* **numeric keycodes:** Only use these if you are using version 1.x   [keycode chart](https://www.toptal.com/developers/keycode) to find any keyâ€™s number. Else use `"w"`
> * **MEGA HINT**  look a the p5 refference for [keyIsDown()](https://p5js.org/reference/p5/keyIsDown/)

### **1.1. Sprite Movement but better**
Instead of just moving up/down/left/right, we are using Tank Controls. Your sprite has a direction (angle) it is facing.
* Rotating (A/D): This just changes the sprite.angle  
* Moving (W/S): If your sprite is facing 45 degrees, "forward" means moving a little bit on the X-axis and a little bit on the Y-axis at the same time.
You don't need to be a calculus expert to use these! Think of them as Percentage Calculators:
* cos(angle): what percentage of your speed should go Left/Right.
* sin(angle): what percentage of your speed should go Up/Down.

When we multiply them by sprite.speed, the sprite moves perfectly in the direction it is pointing


Partial hint on how to rotate and move your sprite:
  ```js
  // Rotate left (A)
  if (keyIsDown(65)) {
    sprite.angle -= sprite.rotationSpeed;
  }

  // Move forward (W)
  if (keyIsDown(87)) {
    sprite.cx += cos(sprite.angle) * sprite.speed;
    sprite.cy += sin(sprite.angle) * sprite.speed;
  }

```

### **2. Draw Four Shapes**

* Create four different shapes, one in each quadrant.
* Use the objects in the starter code (star, poly, sqr) to store their x, y, color, and isHit status.
---


### **4. Shape Collision**

> [!HINT]
> start with 1 shape collision, only if that works add on the others.

* Complete the `distance()` function to detect overlaps using the `dist()` function.
* Inside `draw()`, check each shape for collisions.
* If a collision occurs:
   * Change the **colour of that shape only**.
   * Update its `isHit` flag so it only counts once.


---


### **5. Counter Implementation**


* Add a counter at the top of the screen showing how many shapes have been hit.
* The counter should **only increase once per shape**.
* Use `isHit` to prevent double-counting.


---


### **6. Add Comments**


* Write meaningful comments throughout your code explaining what each section does.


---


## **Part 2 to get 80% and above**


### **1. Add a Second Player**
* Add a second sprite controlled with the **Arrow Keys**.

### **2. Drag-and-Drop Shapes**
* Allow the user to click and [drag](https://p5js.org/reference/p5/mouseDragged/) shapes to reposition them.

---


## **Starter Code**


### **Model (Data Storage)**


```js
// Model
let sprite = {
  cx: 200,
  cy: 200,
  angle: 0,
  speed: 3,
  rotationSpeed: 3
};

let star = {};
let poly = {};
let sqr = {};
let hitCount = 0;
```


### **View (Display Elements)**


```js
// View
function setup() {
   createCanvas(600, 400);
   textSize(24);
   angleMode(DEGREES);
}//end set up


function draw() {
   background(220);


   // Draw counter
   fill(0);
   text("Shapes hit: " + hitCount, 10, 30);


   // Draw player sprite
   fill(sprite.colour);
   rect(sprite.cx, sprite.cy, 30, 30);


   // TODO: draw shapes here


   // Call movement and hitBox
   movement(); 
}// end draw
```


### **Controller (Logic and Interaction)**


```js
// Controller
function movement() {
   // TODO: add WASD movement
   // Remember to wrap around edges
}// end movement


function hitBox(x1, y1, x2, y2, r) {
  // return true if colliding,
 // return false if  not
}// end of distance
```






## **Helper Functions**


```js
// Draw polygon
function polygon(x, y, radius, npoints) {
   const angle = 360 / npoints; 
   beginShape();
   for (let i = 0; i < npoints; i++) {
       const currentAngle = angle * i - 90;
       const sx = x + cos(currentAngle) * radius;
       const sy = y + sin(currentAngle) * radius;
       vertex(sx, sy);
   }
   endShape(CLOSE);
}


// Draw star
function drawStar(startX, startY, sides, radius1, radius2) {
   beginShape();
   for (let i = 0; i < sides * 2; i++) {
       let angle = map(i, 0, sides * 2, 0, 360) + 15;
       let r = (i % 2 === 0) ? radius1 : radius2;
       let x = cos(angle) * r + startX;
       let y = sin(angle) * r + startY;
       vertex(x, y);
   }
   endShape(CLOSE);
}
```



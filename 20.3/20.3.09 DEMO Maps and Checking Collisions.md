# 20.3.09 Demo: Maps and Checking Collisions
```
20.3.09 Demo: Maps and Checking Collisions
```

## Step 1: Creating Wall Lists

* Each wall block is stored as an **object** inside a **wall list**.
* Each object has `x` and `y` coordinates.
* You can have multiple wall lists for different layers of your maze.

```javascript
// Wall list 1
let walls1 = [
  {x:50,  y:200},
  {x:100, y:200},
  {x:150, y:200},
  {x:200, y:200}
];

// Wall list 2
let walls2 = [
  {x:50,  y:100},
  {x:100, y:100},
  {x:150, y:100},
  {x:200, y:100}
];

let wallSize = 40
```

> [!NOTE]
> Using **objects** makes it easier to manage walls. Each wall knows its own coordinates. Multiple lists allow you to organize a maze more clearly.

---

## Step 2: Drawing All Walls

```javascript
function drawWalls(wallsArray, size) {
  fill(100, 100, 150);
  for (let i = 0; i < wallsArray.length; i++) {
    rect(wallsArray[i].x, wallsArray[i].y, size, size);
  }
}
```

```javascript
function setup() {
  createCanvas(400, 400);
}

function draw() {
  background(220);

  // Draw all wall lists
  drawWalls(walls1, wallSize);
  drawWalls(walls2, wallSize);

  movement([walls1, walls2]); // Pass in an array of wall lists IMPORTANT
  drawSprite();
}
```

> [!TIP]
> Drawing walls first ensures the player sprite is drawn **on top**, so it isn’t hidden behind a wall.

---

## Step 3: Adding a Moving Sprite

* Store the sprite’s position, size, and speed inside an **object**.
* This prepares you for more advanced features later, like health or score.

```javascript
let sprite = {
  cx: 100,
  cy: 100,
  size: 30,
  speed: 5
};

function drawSprite() {
  fill("limegreen");
  rect(sprite.cx, sprite.cy, sprite.size, sprite.size);
}
```

> [!NOTE]
> Using an object keeps all the sprite properties in one place. Easy to extend later.

---

## Step 4: The `movement()` Function

The `movement()` function predicts where the sprite wants to move and checks for collisions **before updating the position**.
>[!IMPORTANT]
>ALL of step 4 needs to be added to the `movement` function. 
### Step 4a: Predicting the Next Move

```javascript
function movement(wallLists) {
  let nextX = sprite.cx; // Where the sprite wants to move next
  let nextY = sprite.cy;



}//end fo movement
```

> [!TIP]
> Always test a move **before updating the real position**. This prevents “teleporting” through walls.

---

### Step 4b: Movement with WASD

```javascript
if (keyIsDown(65)) { // A
  nextX -= sprite.speed;
}
if (keyIsDown(68)) { // D
  nextX += sprite.speed;
}
if (keyIsDown(87)) { // W
  nextY -= sprite.speed;
}
if (keyIsDown(83)) { // S
  nextY += sprite.speed;
}
```

> [!NOTE]
> We still haven’t changed the sprite’s real position yet. were only planning the move.

---

### Step 4c: Testing for Collisions

* We check **all wall lists** using a helper function.
* If the move would overlap **any wall**, it is blocked.

```javascript
let canMove = true; // Assume the move is safe

// Loop through each wall list
for (let j = 0; j < wallLists.length; j++) {
  if (checkCollisions(nextX, nextY, wallLists[j], wallSize)) {
    canMove = false;
    break; // Stop checking if collision is found
  }
}
```

> [!TIP]
> This uses **AABB collision detection** (Axis-Aligned Bounding Box) for rectangles.
> The `break` stops the loop as soon as a collision is detected, saving processing time.

---

### Step 4d: Moving Safely

```javascript
if (canMove) {
  sprite.cx = nextX// Update X position only if safe
  sprite.cy = nextY// Update Y position only if safe
}
```

> [!TIP]
> Always separate **checking** from **updating**. First predict, check collisions, then move.

---

### Step 5: Collision Helper Function

* This helper checks one wall list for collisions.
* It returns `true` if the sprite would collide with a wall.

```javascript
function checkCollisions(px, py, wallsArray, size) {
  for (let i = 0; i < wallsArray.length; i++) {
    let wall = wallsArray[i];
    if (px < wall.x + size &&
        px + sprite.size > wall.x &&
        py < wall.y + size &&
        py + sprite.size > wall.y) {
      return true; // Collision detected
    }
  }
  return false; // No collision
}
```






# 20.3.04 Lesson: Async Loading with Promises
```
20.3.04 Lesson: Async Loading with Promises
```


**Things to focus on:**


1. Why loading images can take time and block the sketch.
2. How JavaScript runs image loading in the **background** using Promises.
3. How to display images **only after they’ve finished loading**.
4. How to handle errors gracefully when a file fails to load.


---


## Part 1: Old School `preload()` vs Async


* In early versions of p5js, used `preload()` to load images.
 That function **stopped the entire program** until every asset was done loading.
 * The problem: the page freezes, nothing draws, no interaction until all images finish.
* In modern p5js, it’s better to **load things asynchronously** using Promises, so your sketch can keep running and stay responsive.


> [!NOTE]
> ## INFODUMP:
>
> JavaScript runs on a **single thread**, meaning it can only do one main task at a time.
> If you try to load big files directly, your program **stops and waits**.
>
> * Async loading changes this: it runs the loading task **on a separate timeline**, letting your `draw()` loop keep updating the canvas while the browser fetches images in the background.


## Part 2: Theory: `loadImage()` in a Promise


We can wrap the `loadImage()` function in a Promise:


```javascript
function loadImageAsync(path) {
 return new Promise((resolve, reject) => {
   loadImage(
     path,
     img => resolve(img),   // Success: image is ready
     err => reject(err)     // Failure: something went wrong
   );
 });
}
```


### **Why this works:**


1. `new Promise()` is like saying:
  *“I’ll give you the image later: when it’s ready.”*
2. `resolve` and `reject` are special callbacks:


  * `resolve(img)` tells JavaScript: *“The image is done! You can use it now.”*
  * `reject(err)` says: *“It failed: maybe the path was wrong.”*
3. The function returns **a Promise object**, not an image immediately.
  This lets us “wait” for it to finish using `.then()` or `await`.


* **I don't want to do this version**
 * **I really don't want to do this version**
   * **I really really don't want to do this version**


---


## Part 3: Making Our Own Async Function


Let’s use `await` to make this cleaner.




```javascript
let img;
let loaded = false;


async function loadStuff() {
 img = await loadImage('images/bart.png');
 loaded = true;  // Mark flag as finished
}


function setup() {
 createCanvas(400, 400);
 loadStuff();  // start loading in background
}
```


**Why this works:**


* `loadStuff()` starts running but doesn’t stop `setup()` or `draw()`.
* The keyword `await` pauses the `loadStuff()` function **only inside that function**, not the entire program.
* While `setup()` is waiting, the browser can still do other work (like drawing or handling user input).
* Once the image is ready, `await` returns the loaded image and stores it in `img`.
* When `loaded` changes to `true`, `draw()` knows it can show the image.


---


## Part 4: Drawing the Image in `draw()`


```javascript
function draw() {
 background(220);


/*
Super lazy moment
if(loaded) is the same as if(loaded==true)
why? becase the variable is = true or false.
*/


 if (loaded) {
   image(img, 0, 0, 400, 400);  // Draw only after it's ready
 } else {
   text("Loading image...", 20, 200);
 }
}
```


### **Why this works:**


* The `draw()` loop runs ~60 times per second no matter what.
* At first, `loaded` is `false`, so we show “Loading image…”.
* Once `loadStuff()` finishes, it sets `loaded = true`.
* From that frame onward, the `if` condition flips, and the image is displayed.






---


## Part 5: How the Background Process Works


1. `loadImage()` sends a **request** to the browser.
  The file starts downloading, but your code moves on immediately.
2. The download happens **in parallel**, outside the main JS thread.
3. When done, the browser notifies p5js, which calls your success callback (`resolve`).
4. The Promise “resolves,” and your code resumes after `await` or runs the `.then()` function.
5. If something goes wrong (like a 404 error), it “rejects” and triggers `.catch()`.
> [!TIP]
> **Analogy:**
> 1. You order pizza online (call `loadImage()`),
> 2. keep playing your game (`draw()` keeps running),
> 3. only when the pizza arrives (Promise resolves) do you eat it (draw the image).
>
>---


## Part 6: Summary Table


| Concept           | How it Works                                                                 |
| ----------------- | ---------------------------------------------------------------------------- |
| **Promise**       | A placeholder for a value that will arrive later.                            |
| **resolve()**     | Called when the image successfully loads.                                    |
| **reject()**      | Called if the image fails to load.                                           |
| **.then()**       | Runs after the Promise finishes (like “when ready, do this”).                |
| **.catch()**      | Runs if the Promise fails (useful for debugging or fallback images).         |
| **Async Loading** | Lets your sketch run normally while assets load in the background.           |
| **await**         | Pauses inside one async function until the Promise finishes, then continues. |


---


## TL;DR: What’s Really Happening


1. You **ask** for the image (but don’t get it right away).
2. The browser downloads it **behind the scenes**.
3. JavaScript **keeps running** your `draw()` loop doesn’t stop.
4. When it’s ready, the Promise resolves and your code updates to show it.


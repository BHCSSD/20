# 20.4.08 Demo: Maps and Checking Collisions
```
20.4.08 Demo: Maps and Checking Collisions
```
**Things to focus on:**
* Using Objects to store maps in **parallel arrays**
* Updating `movement` to call `checkCollisions` to predict the future
* updating `checkCollision` to work with rects






## Step 1: Drawing the Walls




* Each wall block is drawn using values from two **parallel arrays**
   * one for `x` positions, and one for `y` positions


```javascript
let wallX = [50,  100, 150, 200, 250, 300, 350]; // X coordinates
let wallY = [200, 200, 200, 200, 200, 200, 200]; // Y coordinates
let wallSize = 40; // Size of each wall block


function setup() {
 createCanvas(400, 400);
 noStroke();
 textAlign(CENTER);
}


function draw() {
 background(220);
  fill(100, 100, 150);//wall colour
 // Loop through the parallel arrays
 for (let i = 0; i < wallX.length; i++) {
   rect(wallX[i], wallY[i], wallSize, wallSize);
 }//end of for


}//end  draw
```


### What’s Happening


* `wallX` and `wallY` each store numbers that line up.


 * **Reminder:** The indexes in both arrays describe the same wall block, they **must** match.
* The `for` loop runs once for every block and draws each rectangle at its matching position.


---


## Step 2: Adding a Moving Sprite


Add a **sprite** that can move around using the arrow keys.


* **Reminder:** We store the sprite’s position, size, and speed inside an **object**.
   * Since we’re working with JSON (JavaScript **Object** Notation), this should give you a clue about where we’re heading next... *HINT HINT.*


```javascript
let sprite = {
 x: 100,
 y: 100,
 size: 30,
 speed: 2
};
```
```javascript
 //Draw player
 fill("limegreen");
 rect(sprite.x, sprite.y, sprite.size, sprite.size);
 ```
---


## Step 3: The `movement()` Function


The `movement()` function is responsible for **moving the player** and checking if it bumps into a wall **before** actually moving.
> [!IMPORTANT]
> All of step 3 is to be added inside of the `movement()` function


### Step 3a: Predicting the Next Move


```javascript
function movement() {
 // Step 3a: Store possible next position
 let nextX = sprite.x;
 let nextY = sprite.y;


}//end movement
```


Instead of moving the sprite right away, we create two **temporary variables**: `nextX` and `nextY`.
* These represent *where the sprite wants to go next* **before** we decide if it’s safe to move.




### Step 3b: Movement


```javascript
 // Step 3b: Update the potential position based on key presses
 if (keyIsDown(LEFT_ARROW)) {
   nextX = nextX-sprite.speed;
 }


 if (keyIsDown(RIGHT_ARROW)) {
   nextX = nextX+sprite.speed;
 }


 if (keyIsDown(UP_ARROW)) {
   nextY = nextY-sprite.speed;
 }


 if (keyIsDown(DOWN_ARROW)) {
   nextY = nextY+sprite.speed;
 }
```


We use the arrow keys to change `nextX` and `nextY`.
Each key press moves the sprite by `sprite.speed` in that direction.
> [!NOTE]
>  We **still haven’t changed** the sprite’s real position yet we’re just *planning* what the next move would be.


### Step 3c: Testing for Collisions


```javascript
 // Step 3c: Check if the new position hits any wall
 let canMove = true;
 for (let i = 0; i < wallX.length; i++) {
   if ( checkCollision(nextX, nextY, wallX[i], wallY[i]) ) {
     canMove = false;
     break; //exit loop
   }
 }//endfor
```


Before we move, we check the new position against every wall block.


* If `checkCollision()` returns **true**, it means the sprite would overlap a wall.
* We set `canMove` to **false**, and the loop stops early with `break;`.


This prevents the player from moving **through** walls.






### Step 3d: Moving Safely


```javascript
 // Step 3d: Only update our sprite object if no collision
 if (canMove) {
   sprite.x = nextX;
   sprite.y = nextY;
 }//end if


```


If no collision was found, update the real position inside the sprite object.
The sprite now officially moves to the new location.


If there **was** a collision, nothing happens, the sprite stays where it is.


> [!NOTE]
> ### TL;DR
>
> | Step | What Happens                             | Why It’s Important                        |
> | ---- | ---------------------------------------- | ----------------------------------------- |
> | 1    | Copy the current position                | Lets us “test” a move before doing it     |
> | 2    | Change `nextX`/`nextY` with arrow keys | Lets the player move                      |
> | 3    | Check for collisions                     | Stops the sprite from going through walls |
> | 4    | Update the sprite’s real position        | Moves only when it’s safe                 |
>
> ---


## Step 4: Understanding the Collision
> [!NOTE]
> ## INFODUMP:
>
> The function `checkCollision()` uses a simple logic called **AABB (Axis-Aligned Bounding Box)** collision detection.
>
> It checks if two rectangles (the sprite and the wall block) **overlap** by comparing their edges.

```javascript
px < wx + wallSize       // sprite's left edge is left of wall's right edge
px + sprite.size > wx    // sprite's right edge is right of wall's left edge
py < wy + wallSize       // sprite's top edge is above wall's bottom edge
py + sprite.size > wy    // sprite's bottom edge is below wall's top edge
```


If **all four** are true, the two rectangles overlap, meaning a collision has occurred.


```javascript
// --- Simple AABB collision ---
function checkCollision(px, py, wx, wy) {
 // Check if player's rectangle overlaps the wall rectangle
 if (px < wx+wallSize &&  // Player’s left edge is to the left of wall’s right edge
   px+sprite.size > wx && // Player’s right edge is to the right of wall’s left edge
   py < wy+wallSize &&    // Player’s top edge is above wall’s bottom edge
   py+sprite.size > wy    // Player’s bottom edge is below wall’s top edge
 ) {
   return true; // Collision detected
 } else {
   return false; // No collision
 }
}


```
